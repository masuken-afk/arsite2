<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>WebXR AR Fixed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: sans-serif;
      background: #000;
    }
    #enterAR {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 18px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: none;
      z-index: 1000;
    }
    #enterAR:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #status {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 15px 25px;
      border-radius: 8px;
      text-align: center;
      max-width: 80%;
      z-index: 1000;
    }
    #debugLog {
      position: absolute;
      top: 80px;
      left: 10px;
      right: 10px;
      color: #0f0;
      background: rgba(0,0,0,0.9);
      padding: 10px;
      border-radius: 5px;
      font-size: 11px;
      font-family: monospace;
      max-height: 300px;
      overflow-y: auto;
      z-index: 999;
    }
    .log-error { color: #f44; }
    .log-success { color: #4f4; }
    .log-info { color: #4af; }
  </style>
</head>
<body>
<div id="status">初期化中...</div>
<div id="debugLog"></div>
<button id="enterAR" disabled>ARを起動</button>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

let scene, camera, renderer;
let controller;
let reticle;
let hitTestSource = null;
let hitTestSourceRequested = false;
let model;
let isModelLoaded = false;
let isWebXRSupported = false;

// デバッグログ
function log(message, type = 'info') {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`[${timestamp}] ${message}`);
  
  const debugLog = document.getElementById("debugLog");
  const className = `log-${type}`;
  debugLog.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span><br>`;
  debugLog.scrollTop = debugLog.scrollHeight;
}

function updateStatus(message) {
  document.getElementById("status").textContent = message;
  log(message, 'info');
}

// 初期化
async function init() {
  try {
    log("=== 初期化開始 ===", 'info');
    log(`User Agent: ${navigator.userAgent}`, 'info');
    
    // Three.js基本設定
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    
    renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true 
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    log("Three.js レンダラー初期化完了", 'success');
    
    // ライト追加
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 2);
    scene.add(light);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);
    
    log("ライト設定完了", 'success');
    
    // レティクル（ターゲット表示）
    const geometry = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    reticle = new THREE.Mesh(geometry, material);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);
    
    log("レティクル作成完了", 'success');
    
    // WebXR対応チェック
    await checkWebXRSupport();
    
    // モデル読み込み
    await loadModel();
    
    // すべて準備完了
    if (isWebXRSupported && isModelLoaded) {
      updateStatus("準備完了！ARボタンを押してください");
      document.getElementById("enterAR").disabled = false;
      document.getElementById("enterAR").style.display = "block";
    }
    
  } catch (error) {
    log(`初期化エラー: ${error.message}`, 'error');
    updateStatus("初期化に失敗しました");
    console.error(error);
  }
}

// WebXR対応確認
async function checkWebXRSupport() {
  log("=== WebXR対応チェック ===", 'info');
  
  if (!('xr' in navigator)) {
    log("navigator.xr が存在しません", 'error');
    updateStatus("このブラウザはWebXRに対応していません");
    return false;
  }
  
  log("navigator.xr 検出", 'success');
  
  try {
    const supported = await navigator.xr.isSessionSupported('immersive-ar');
    log(`immersive-ar サポート: ${supported}`, supported ? 'success' : 'error');
    
    if (supported) {
      isWebXRSupported = true;
      updateStatus("WebXR AR対応を確認");
      return true;
    } else {
      updateStatus("このデバイスはARに対応していません");
      log("AR非対応デバイスです", 'error');
      return false;
    }
  } catch (error) {
    log(`WebXRチェックエラー: ${error.message}`, 'error');
    updateStatus("WebXR確認に失敗");
    return false;
  }
}

// モデル読み込み
function loadModel() {
  return new Promise((resolve, reject) => {
    log("=== モデル読み込み開始 ===", 'info');
    updateStatus("3Dモデル読み込み中...");
    
    const loader = new GLTFLoader();
    const modelPath = "model/mascot.glb";
    
    log(`読み込みパス: ${modelPath}`, 'info');
    log(`絶対URL: ${window.location.origin}${window.location.pathname.replace('index.html', '')}${modelPath}`, 'info');
    
    loader.load(
      modelPath,
      (gltf) => {
        log("モデル読み込み成功！", 'success');
        model = gltf.scene;
        
        // モデル情報をログ出力
        log(`モデルの子要素数: ${model.children.length}`, 'info');
        
        // バウンディングボックスを計算してサイズ確認
        const box = new THREE.Box3().setFromObject(model);
        const size = box.getSize(new THREE.Vector3());
        log(`モデルサイズ: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'info');
        
        // スケール調整
        model.scale.set(0.3, 0.3, 0.3);
        log("モデルスケール設定: 0.3", 'success');
        
        isModelLoaded = true;
        updateStatus("モデル読み込み完了");
        resolve();
      },
      (xhr) => {
        if (xhr.lengthComputable) {
          const percentComplete = Math.round((xhr.loaded / xhr.total) * 100);
          log(`読み込み進行: ${percentComplete}% (${xhr.loaded}/${xhr.total} bytes)`, 'info');
          updateStatus(`モデル読み込み中... ${percentComplete}%`);
        }
      },
      (error) => {
        log(`モデル読み込みエラー: ${error.message}`, 'error');
        console.error("詳細エラー:", error);
        updateStatus("モデルの読み込みに失敗しました");
        
        // フォールバック: デフォルトモデルを作成
        log("フォールバックモデルを作成", 'info');
        createFallbackModel();
        resolve();
      }
    );
  });
}

// フォールバックモデル作成
function createFallbackModel() {
  const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
  const material = new THREE.MeshStandardMaterial({ 
    color: 0xff6b6b,
    metalness: 0.5,
    roughness: 0.5
  });
  model = new THREE.Mesh(geometry, material);
  isModelLoaded = true;
  log("フォールバック立方体を作成", 'success');
  updateStatus("デフォルトモデルで準備完了");
}

// ARセッション開始
async function startAR() {
  log("=== AR起動開始 ===", 'info');
  
  if (!isWebXRSupported) {
    alert("このデバイスはARに対応していません");
    log("AR非対応のため起動中止", 'error');
    return;
  }
  
  if (!isModelLoaded) {
    alert("モデルの読み込みが完了していません");
    log("モデル未読み込みのため起動中止", 'error');
    return;
  }
  
  try {
    updateStatus("ARセッション開始中...");
    log("XRSessionをリクエスト", 'info');
    
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: document.body }
    });
    
    log("ARセッション取得成功", 'success');
    
    await renderer.xr.setSession(session);
    log("レンダラーにセッション設定完了", 'success');
    
    // UI非表示
    document.getElementById("enterAR").style.display = "none";
    document.getElementById("status").style.display = "none";
    document.getElementById("debugLog").style.display = "none";
    
    // コントローラー設定
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);
    
    log("コントローラー設定完了", 'success');
    
    // アニメーションループ開始
    renderer.setAnimationLoop(render);
    log("レンダリングループ開始", 'success');
    
    // セッション終了時のハンドラ
    session.addEventListener('end', () => {
      log("ARセッション終了", 'info');
      hitTestSourceRequested = false;
      hitTestSource = null;
      document.getElementById("enterAR").style.display = "block";
      document.getElementById("status").style.display = "block";
      document.getElementById("debugLog").style.display = "block";
      updateStatus("ARセッション終了");
    });
    
  } catch (error) {
    log(`ARセッションエラー: ${error.name} - ${error.message}`, 'error');
    console.error("詳細エラー:", error);
    updateStatus("ARの起動に失敗しました");
    alert(`ARエラー: ${error.message}`);
    document.getElementById("enterAR").style.display = "block";
  }
}

// オブジェクト配置
function onSelect() {
  if (reticle.visible && model) {
    log("オブジェクトを配置", 'success');
    const placedModel = model.clone();
    placedModel.position.setFromMatrixPosition(reticle.matrix);
    scene.add(placedModel);
  } else {
    log("配置失敗: reticle非表示またはモデルなし", 'error');
  }
}

// レンダリングループ
function render(timestamp, frame) {
  if (frame) {
    const referenceSpace = renderer.xr.getReferenceSpace();
    const session = renderer.xr.getSession();
    
    // HitTest初期化
    if (!hitTestSourceRequested) {
      session.requestReferenceSpace('viewer').then((space) => {
        session.requestHitTestSource({ space }).then((source) => {
          hitTestSource = source;
          log("HitTestSource初期化完了", 'success');
        }).catch((error) => {
          log(`HitTestSource取得エラー: ${error.message}`, 'error');
        });
      }).catch((error) => {
        log(`Viewer ReferenceSpace取得エラー: ${error.message}`, 'error');
      });
      hitTestSourceRequested = true;
    }
    
    // HitTest実行
    if (hitTestSource) {
      const hitTestResults = frame.getHitTestResults(hitTestSource);
      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        const pose = hit.getPose(referenceSpace);
        
        if (pose) {
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        }
      } else {
        reticle.visible = false;
      }
    }
  }
  
  renderer.render(scene, camera);
}

// イベントリスナー
document.getElementById("enterAR").addEventListener("click", startAR);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 初期化実行
init();
</script>
</body>
</html>